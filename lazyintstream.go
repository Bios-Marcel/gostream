// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package gostream

type lazyIntStream struct {
	data      []int
	functions []interface{}
}

//IntFilter is the type of function that filters values.
type IntFilter func(value int) bool

//IntMapper is the type of function that maps values.
type IntMapper func(value int) int

//StreamIntLazy creates a lazy StreamInt that
//uses a copy of the passed array.
func StreamIntLazy(data []int) IntStream {
	defensiveCopy := make([]int, len(data))
	copy(defensiveCopy, data)
	return &lazyIntStream{
		data: defensiveCopy,
	}
}

func (stream *lazyIntStream) Filter(filterFunction func(value int) bool) IntStream {
	stream.functions = append(stream.functions, (IntFilter)(filterFunction))
	return stream
}

func (stream *lazyIntStream) Map(mapFunction func(value int) int) IntStream {
	stream.functions = append(stream.functions, (IntMapper)(mapFunction))
	return stream
}

func (stream *lazyIntStream) FindFirst() *int {
FINDFIRST_VALUE_LOOP:
	for _, value := range stream.data {
		for _, function := range stream.functions {
			castFilter, ok := function.(IntFilter)
			if ok {
				if castFilter(value) {
					//Continue, since value fits the filter
					continue
				} else {
					//Value has to be sorted out, therefore skip to next value
					continue FINDFIRST_VALUE_LOOP
				}
			}

			castMapper, ok := function.(IntMapper)
			if ok {
				value = castMapper(value)
				continue
			}

		}

		//As this is a terminating function, quit if we successfully end a single iteration.
		return &value
	}

	return nil
}

func (stream *lazyIntStream) Reduce(reduceFunction func(one, two int) int) *int {
	//This implementation is just me being lazy, instead of a proper
	//optimized solution, I'll simply call collect and reduce the result.
	return reduceInt(reduceFunction, stream.Collect())
}

func (stream *lazyIntStream) Collect() []int {
	collectedData := make([]int, 0)
COLLECT_VALUE_LOOP:
	for _, value := range stream.data {
		for _, function := range stream.functions {
			castFilter, ok := function.(IntFilter)
			if ok {
				if castFilter(value) {
					//Continue, since value fits the filter
					continue
				} else {
					//Value has to be sorted out, therefore skip to next value
					continue COLLECT_VALUE_LOOP
				}
			}

			castMapper, ok := function.(IntMapper)
			if ok {
				value = castMapper(value)
				continue
			}

		}

		collectedData = append(collectedData, value)
	}

	return collectedData
}
